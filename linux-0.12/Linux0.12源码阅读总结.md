
#Linux-0.12源码阅读总结#

虽然`Linux-0.12`的源码量不大，但是要逐一弄清楚也不是一天两天的事，参考赵炯先生的《Linux内核完全剖析》将代码阅读了一遍，但是往往专注于函数或细节时就容易忽略大的框架，也容易将相关的机制割裂，这里将阅读过程中的一些自认为比较完整的一些过程或机制总结一下，作为今后查阅的资料备份。

### 引导过程 ###


### 内存管理 ###
内核管理所有物理内存，可以访问整个物理空间

单个进城使用该任务号对应的64M内存空间（虚拟地址），跳入内核则切换段寄存器，代码和数据，由于所有进城使用一个页表，进城切换不需要切换页表

缺页处理—
execve并没有对内存分页进行处理，仅处理了参数与环境变量，分配具体物理页！其他部分则设定执行文件inode，代码起始地址，数据起始地址。
在缺页处理中，根据当前缺页的地址，计算出它属于什么，首先确定是否是需换入页，其次看它是代码，数据，还是用于堆与栈的内存（空白），代码与数据即用前面execve中设置的代码和数据范围来判断！


13
-------------------------------------
关于物理内存管理，按照Linux 0.12中用户划分后，分为内核区，块设备缓冲区，虚拟磁盘，主内存四部分
物理内存最大支持16M，而内核使用的虚拟地址范围也为0-16M，且将物理内存16M一一映射到内核虚拟地址范围。
所以在内核中使用内核的GDT的代码与数据表项都能访问0-16M的物理内存。

>> 后面阅读高版本源码时，每个进程4G虚拟内存，内核占据高端1G虚拟内存时，物理内存的管理方法。


--------------------------------------
交换分区：
交换分区是块设备中独立的一个分区，初始化交换分区即将该分区的第一个"页"大小的磁盘块读入内存，校验交换分区标记

交换分区最多支持 SWAP_BITS 大小的交换分区，一旦大于这个值则将交换分区设置为该值。

由于交换分区位图中最后10个字节为标记，且校验后清0，所以如果交换分区足够大，那么10个字节中的位对应的
交换块就废弃了。

由于位图块是不会被写入到磁盘的，所以它保持了格式化磁盘后的状态。


### 系统调用 ###

### 读取硬盘过程 ###

### 打开一个文件的过程 ###

### execve执行过程 ###

### 字符设备 ###

（输出一个字符/读入一个字符）

    包括tty，chr_dev  相互之间关系

### 信号机制 ###

### 文件系统对设备的抽象 ###