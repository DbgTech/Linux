
#Linux-0.12源码阅读总结#

虽然`Linux-0.12`的源码量不大，但是要逐一弄清楚也不是一天两天的事，参考赵炯先生的《Linux内核完全剖析》将代码阅读了一遍，但是往往专注于函数或细节时就容易忽略大的框架，也容易将相关的整体机制或功能割裂，这里将阅读过程中的一些自认为比较完整的一些过程或机制总结一下，作为今后查阅的资料备份。

### 引导过程 ###

机器一旦加电，BIOS即进行硬件自检，完成后将引导设备上的引导扇区加载到`0x7c00`地址处，跳转到这个地址上开始执行引导扇区的代码。

**boot/bootsect.S**

`linux0.12`中引导扇区对应文件`bootsect.S`，它首先将自己移动到`0x90000`地址处（现在占用的这地地址处后面要加载内核），校正磁盘的参数，确保最大扇区数设置为18。加载引导扇区后的四个扇区到引导扇区后面的地址处，这四个扇区中保存了`setup.S`文件编译出的代码，后面会简单说这个模块。输出引导信息，然后调用`read_it`函数将真正的内核文件加载起来，它位于`setup.S`编译出来的模块之后，它的加载地址为`0x10000`。

其实这里的引导程序限制了`setup.S`的大小，最大不能超过四个扇区，即2Kb；而真正的内核文件的大小也有限制，从现在看它是从`0x10000`地址开始加载，而结束地址则为`0x90000`，如果超过这个地址就覆盖到了正执行的这个引导扇区，所以内核文件最大为`0x80000`，在当时Linus先生认为这个大小足够了。

> 这有一个问题，为什么内核模块要从`0x10000`开始进行加载呢？如果从`0x0`岂不是更方便？如果对BIOS有所了解就会知道，BIOS中断位于0地址开始处，占用1Kb空间。如果从0地址开始加载，那么这些中断函数就会被覆盖，后面`setup.S`中还需要使用BIOS中断获取信息，所以这里要闪开0地指处1K。

**boot/setup.S**

setup模块首先使用BIOS中断获取了硬盘，显示器，内存等参数，这些参数在后面初始化Linux系统有用处；获取硬盘参数列表，并且判断系统的硬盘`hd1`是否存在。这些数据被放在`0x90000`地址开始的内存中，这段内存用于放置引导扇区，前面已经执行完毕，这里重用这块内存。对于显示参数，如果获取的不对，则调用chsvga函数根据显卡类型获取参数。

完成参数获取后，BIOS中断的使命也就完成了，这里就将整个内核模块system向前移动到了0地址处，system模块编译时指定起始地址为0，所以这里将它移动到0地址处也不需要进行重定位了。

接下来就是完成系统保护开启设置了：

* 加载IDTR寄存器
* 加载GDTR寄存器
* 开启A20地址线（使用键盘接口）
* 重置8259A芯片，设置中断号从`0x20`开始，并且屏蔽掉所有中断
* 开启保护模式，并进行长跳转完成CS寄存器切换

开启保护模式后长跳转指令为`ljmp 0, 8`，即设置cs寄存器为`0x8`，eip为0。根据GDT表可知这个地址`0x0008:0x00000000`其实就是当前的物理0地址，即system模块的起始处（前面进行的复制）。

**boot/head.s**

setup 模块的开始处其实是`head.s`文件编译出的模块，setup中进行保护模式设置，并进入了保护模式。这里则继续进行系统的初始化设置。

首先重置各个数据段寄存器，然后重新加载`IDTR/GDTR`两个寄存器，前面setup中设置的中断表和全局描述符表位于setup中，这块内存在后面会被用作其他地方，防止被覆盖则需要将这两个表设置到不会被覆盖的地方，这里及head中的末尾处，它是内核模块，占用内存在整个操作系统生命周期中也不会挪作它用。

注意这里设置了栈，它是从`stack_start`结构体中加载的内容，这是这里将栈底设置为`user_stack`，它就是之后第一个进程所用的用户栈（现在还没有开启分页，还没有区分R3和R0，所以这个内存内核先用着，后面就专用于R3栈了，内核栈会重新设置）。检查A20地址线是否开启，检查浮点数运算芯片。

下面就是设置页表，将从0地址开始的五页设置为初始页表，第一页用作页目录，后面四页作为映射16M物理内存的页表项进行初始化，即`0-16M`的物理内存与地址空间的`0-16M`作一对一映射，这里一方面方便内核初始化，也方便物理内存管理。设置完页表后，即可开启分页，然后跳转到内核C代码的入口地址处。

这里的C代码入口函数即`init/main.c`中的`main`函数。

**init/main.c**

`main.c`中代码比较简单，但是它涉及的知识很多，这里简要叙述一下它的过程，详细内容再阅读具体代码。

首先设置环境变量，将硬盘参数复制到全局变量中保存，以备后面使用；根据内存大小，设置块设备缓冲区，虚拟盘所占内存，最后将剩余内存都充做主内存，用于分配。后面依次对系统的各个部分进行初始化，如下：


* 内存初始化： 内存初始化中，将主内存按照4K分块，`mem_map`数组每项指向主内存的4K块，用于表示当前块有没有被引用，以及被引用几次。对于不满16M时，将后面不满16M的map项设置为已占用，防止出错。
* 中断初始化：调用`set_trap_gate`和`set_system_gate`来设置IDT表中的对应中断项，主要是设置其响应函数。将不支持的中断项设置为`reserved`，防止出现后造成系统崩溃。最后开启两片中断芯片的链接。
* 块设备初始化：块设备请求时，将所有信息封装成一个request项，这里只需要将request数组各项初始化即可。
* 字符设备初始化：实际为空，字符设备无需在此初始化。
* tty设备以及串口和控制台初始化：这个主要是这三项中用到的串口表，伪终端表，控制台表，串口请求项等初始化。
* 时间初始化：将从CMOS中读取的时间转换为开机时间，作为之后计算其他时间基础。
* 调度初始化：即手工设置第一个进程，设置tss，ldt在GDT中表项，加载TR寄存器和LDTR寄存器，设置定时芯片的中断响应函数，以及系统调用。这基本为第一个进程的执行准备好了条件。
* 块设备缓存初始化：这个主要完成了块缓存区的初始化，从低内存开始保存块设备请求项缓存块描述符，高地址处以1K大小划分内存，直到将整个块设备缓存区消耗完。
* 硬盘初始化：设置硬盘中断响应函数，并且开启硬盘中断。
* 软盘初始化：设置软盘的中断响应函数，开启软盘中断屏蔽位。

最后开启终端，调用`move_to_user_mode()`宏通过在栈上构建终端返回栈帧，经过`iret`指令返回到R3继续执行。这里返回R3就是执行在了任务0中，任务0是空闲进程，系统进入空闲状态后会切换到该进程。

同时任务0在进入空闲状态之前，首先会调用 `fork`函数创建init进程，它用于进一步初始化。在init进程中，它完全复制了任务0的进程信息，开始初始化系统的硬盘信息，加载根文件系统。打开标准输入输出句柄，创建shell进程执行初始化文件`/etc/rc`，而init在初始化文件完成后，创建shell接口进程，进而退化为Shell进程的Deamon进程，用于监控Shell进程退出后再次执行该进程。

至此，整个引导过程结束，系统进入到Shell接口，可以开始接收用户输入，执行Shell命令。

### 内存管理 ###

内存管理分为物理内存管理和虚拟内存管理，在虚拟内存管理中其实还包含了块设备缓冲区，虚拟盘，应用层的堆内存管理等。

**物理内存管理**

代码的执行，数据的访问等最终都要落实到具体的物理内存块上才能得到数据，否则会出现问题，但是在Linux我们已知它已经开启了保护模式以及分页，所有访问的内存地址都是虚拟内存，内核中也不例外，那么它如何管理物理内存呢？

要想避开保护模式下线性地址的影响，直接对物理内存进行操作，最简单的办法就是将物理内存等地址映射到虚拟内存中，在linux0.12中则将内核的低16M地址空间直接与16M物理内存进行一一映射，那么在内核中操作这低16M地址空间就等于直接操作物理内存了。通过这种一一映射的方式，一方面简化了物理内存管理，另外一方面也简化了分页功能开启。

> 在后面块设备缓冲区，虚拟盘等物理内存相关的这些操作，都是通过这个一对一的映射完成的对物理内存的操作。

物理内存管理中，将1M（主内存可能的最低端）开始到16M结束的这段内存按照4K的页进行划分，并声明一个`mem_map`全局数组来对主存的每一页使用情况进行记录。其中，如果内存有16M，那么内核结束位置到4M地址处这段内存都会划给块设备缓冲区使用，那么在`mem_map`中就要将这块设置为已占用；而如果物理内存没有16M，则物理内存结束位置到16M这段内存对应的`mem_map`中的项设置为已占用，防止分配。

在Linux0.12中，函数`get_free_page()`用于获取一页空闲内存，它即遍历`mem_map`数组，找到第一项为0的项，即可将对应的页面分配出去。函数`free_page()`用于释放一页内存，`free_page_tables()`则调用前者，用于释放一组内存页，通常是一个进程的页表。

>> 后面阅读高版本源码时，每个进程4G虚拟内存，内核占据高端1G虚拟内存时，物理内存的管理方法。

**虚拟内存管理**

除了上面说的物理内存管理，其实剩下的内存相关的操作都是虚拟内存，使用虚拟地址进行操作。在Linux 0.12中，系统使用了32位的保护模式，并且开启了分页机制，这意味着CPU的寻址空间可以达到4G。按说一个进程可访问的地址空间就可以支持到这么大，但是在Linux 0.12中对地址空间进行了简化，将4G地址空间划分为64个任务，每个任务可占用的虚拟地址空间为64M，任务n的地址空间起始地址为 `n*64M`。

之所以采用这种方式，其实是简化了分页的操作，将4G地址空间划分64个任务，那么整个系统共享一个页表即可，在进行进程切换时不需要对页表进行操作。

> 单个进程使用该任务号对应的64M内存空间（虚拟地址），跳入内核则切换段寄存器，随之代码和数据都进行了切换，由于所有进程使用一个页表，进程切换不需要切换页表


除了任务0和任务1之外，其他的进程的虚拟地址空间都没有物理内存进行一一映射，所有需要访问的内存地址都需要进行物理内存映射后才能访问，所以在获取了空闲物理内存页后，要调用`put_page()`将物理页面映射到指定的虚拟地址上去。这个过程需要操作该进程的页目录项以及页表，将物理内存地址写入到虚拟地址对应的页表项中。`free_page_tables()`用于释放进程的内存，它是完成以4M内存为对齐边界的虚拟内存空间中内存释放的工作，前面说了，它调用`free_page()`完成物理页面的释放。

> 释放了整个进程的地址空间，那其实就将页表进行大量修改，这里需要将CPU中快表内容清空，防止已释放的内存地址仍然存在高速缓存中。

**内存共享**

每个进程中的内存都可以分为几部分，代码，数据，数据包括栈，堆等，其中代码对应的内存一般情况下是不会被修改的，也即如果两个进程执行同一个程序，那么这个程序中的代码在两个进程中是一致的，因此在两个进程之间就可以共享这一部分一致的内存。`share_page()`函数为一个地址`address`寻找其他进程中可以被当前进程共享的物理内存页，共享条件是：1. 两个进程执行同一个程序，2.对应的内存物理页在被读入之后没有修改过。

**页面异常**

页面异常发生在cpu进行内存访问是，可能是因为缺页，或者试图写入只读页面，这时cpu就会进入到异常处理函数中进行处理。由于异常原因有两种情况，所以在异常处理中首先判断出错原因。x86处理器的`error_code`由cpu产生并保存到中断处理的栈上，出错码最低位置是出错原因（1：写出错，0：缺页），而出错地址则保存在CR2寄存器中。

`do_no_page()`完成缺页处理。在进程初始化设置时，内核并不会将进程可用到的内存都一次性分配，而是在进程要访问地址时才进行分配，这样提高内存资源使用率。缺页处理中有三种情况：一种情况是该进程没有可执行文件，那么是内存初始化中缺页，这时不会与其他进程有共享可能，直接申请空白物理页；第二种情况则是有了可执行文件，而这个可执行文件也有其他进程在使用，那么这时就可以尝试共享页面，如果共享成功则可以直接访问；第三种就是前面两种失败，则老实地获取空白物理页，将对应的可执行文件内容从磁盘读取，然后将物理内存映射到访问失败的线性地址上。

> execve函数并没有对内存分页进行处理，仅处理了参数与环境变量，为其分配了具体物理页！其他部分则设定执行文件inode，代码起始地址，数据起始地址。真正的可执行文件到内存的映射是在缺页处理中，根据当前缺页的地址，计算出它属于什么，首先确定是否是需换入页，其次看它是代码，数据，还是用于堆与栈的内存（空白），代码与数据即用前面execve中设置的代码和数据范围来判断！

另外一种页面写保护错误则由`do_wp_page()`处理，这个主要处理的是多个进程共享一个物理页面的情况，这时会将物理页设置为只读方式，如果那一个进程想要写这个页面，cpu就会产生页面异常中断。这也有几种情况：第一种，如果访问内存属于进程的代码段则出错，代码段不允许修改；第二种情况，如果出错页面属于主内存且共享计数为1，则直接取消写保护即可；第三种则就需要申请新的物理页面，然后将该物理页面映射到出错地址并且要复制共享页面内容，最后取消出错进程中该页的只读属性。

**内核中堆管理**

内核中的堆管理是通过`malloc()`和`free_s`函数完成的，是以桶算法为基础的，这个这里不做总结，感兴趣可以参考相应的源码。

**交换分区**

交换分区是块设备中一个独立分区，初始化交换分区即将该分区的第一个"页"大小的磁盘块读入内存，校验交换分区标记。交换分区最多支持 SWAP_BITS 大小的交换分区，一旦大于这个值则将交换分区设置为该值。由于交换分区位图中最后10个字节为标记，且校验后清0，所以如果交换分区足够大，那么10个字节中的位对应的交换块就废弃了。

> 由于交换分区的位图块不会被写入到磁盘，所以第一个盘块始终保持了格式化磁盘后的状态。

交换分区剩余的操作就与块设备完全一致了，按照磁盘块进行读写操作。这部分本应该放到磁盘操作中，但是与内存相关，就先放到这里一起看了。

### 系统调用 ###

linux 0.12中的系统调用是使用中断实现，所有系统调用都使用中断号为0x80的软中断。前面系统初始化中看到，在`trap_init()`函数中完成系统调用中断的设置，其响应函数为`system_call`，执行了中断指令后就会进入内核，如下为`int 0x80`中断的处理函数`system_call`的部分汇编：

```
......
system_call:
	push %ds
	push %es
	push %fs
	pushl %eax		# save the orig_eax eax寄存器保存系统调用号
	pushl %edx
	pushl %ecx		# push %ebx,%ecx,%edx as parameters，ebx/ecx/edx是系统调用参数
	pushl %ebx		# to the system call
	movl $0x10,%edx		# set up ds,es to kernel space
	mov %dx,%ds
	mov %dx,%es
	movl $0x17,%edx		# fs 寄存器指向用户空间
	mov %dx,%fs
	cmpl NR_syscalls,%eax # 对比系统调用号是否比系统调用数多
	jae bad_sys_call
	call sys_call_table(,%eax,4) # 查找 sys_call_table 表，查找要调用的系统调用
	pushl %eax
......
```

从汇编代码可以很容易了解到，系统调用根据`eax`寄存器传入的系统调用号查找系统调用表`sys_call_table`中对应的系统调用处理函数，然后跳转过去进行处理。所以要添加系统调用，首先要在`sys_call_table`中添加两项内容（该全局变量位于`include\linux\sys.h`中），一个函数声明，再就是在`sys_call_table`中添加一项。

这样就能够根据系统调用号找到对应处理函数，进行系统调用处理，其余过程与普通的中断处理一样，这里不做过多总结。

系统调用号位于头文件`include/unistd.h`中，其中定义了所有的系统调用号，同时还定义了系统调用函数。在内核中只需要系统调用号的定义，而在应用层代码库中，则要使用其中定义的系统调用。比如如下为`close()`系统调用的实现，其在`unistd.h`中的宏定义为`_syscall1(int,close,int,fd)`，展开宏后代码形式如下所示：

```
int close(int fd)
{
    long __res;
    __asm__ volatile ("int $0x80"
        : "=a" (__res)
        : "0" (__NR_close),"b" ((long)(fd)));
    if (__res >= 0)
        return (int) __res;
    errno = -__res;
    return -1;
}
```

可知系统调用使用`int 0x80`，其中`eax`中保存了一个值`__NR_close`，即系统调用号，`ebx`等寄存器传参（还有两个可用寄存器，分别是`ecx`，`edx`）。`__NR_close`其实也是一个宏定义，它即`include/unistd.h`中定义的系统调用号。

添加系统调用可以参考`labs`中的试验二的内容。

### 读取硬盘过程 ###



### 打开一个文件的过程 ###



**文件系统对设备的抽象**




### execve执行过程 ###




### 字符设备 ###


（输出一个字符/读入一个字符）

    包括tty，chr_dev  相互之间关系


### 信号机制 ###

信号提供了一种处理异常事件的方法，它也被称为一种软中断。在Linux 0.12中支持的信号及其含义如下表所示：

| 名称 | 编号 | 含义 |       注释       |
|------|-----|-----|-----------------|
| SIGHUP | 1 | Hang Up | 挂断控制终端或进程 |
| SIGINT | 2 | Interrupt | 来自键盘的中断 |
| SIGQUIT | 3 | Quit | 来自键盘的退出 |
| SIGILL | 4 | Illeagle | 非法指令 |
| SIGTRAP | 5 | Trap | 跟踪断点 |
| SIGABRT | 6 | Abort | 异常结束 |
| SIGIOT | 6 | IO Trap | 同上 |
| SIGUNUSED | 7 | Unused | 没有使用 |
| SIGFPE | 8 | FPE | 协处理器出错 |
| SIGKILL | 9 | Kill | 强迫进程终止 |
| SIGUSR1 | 10 | User1 | 用户信号 1，进程可使用 |
| SIGSEGV | 11 | Segment Violation | 无效内存引用 |
| SIGUSR2 | 12 | User2 | 用户信号 2，进程可使用 |
| SIGPIPE | 13 | Pipe | 管道写出错，无读者 |
| SIGALRM | 14 | Alarm | 实时定时器报警 |
| SIGTERM | 15 | Terminate | 进程终止 |
| SIGSTKFLT | 16 | Stack Fault | 栈出错（协处理器） |
| SIGCHLD | 17 | Child | 子进程停止或被终止 |
| SIGCONT | 18 | Continue | 恢复进程继续执行 |
| SIGSTOP | 19 | Stop | 停止进程的执行 |
| SIGTSTP | 20 | TTY Stop | tty 发出停止进程，可忽略 |
| SIGTTIN | 21 | TTY In | 后台进程请求输入 |
| SIGTTOU | 22 | TTY Out | 后台进程请求输出 |

在信号实现中最重要的两个函数，`signal()`和`sigaction()`，它们都用于修改信号的处理函数。`sigaction()`是实现了POSIX所提供的一种可靠处理信号的方法。`signal`是否为兼容而设置的系统调用，它内部其实与`sigaction`的实现相似。

信号有三种处理方法：一是忽略信号，但是无法忽略SIGKILL和SIGSTOP两个信号；第二种是进程定义自己的信号处理程序来处理信号；其三是执行系统的默认信号处理操作，很多信号的默认处理即使终止掉进程。

在内核中信号的实现方式简述如下：

在任务块结构体中有如下的几个字段，它们是内核中表示进程信号的变量：

```
struct task_struct {
    ...
    long signal;                    // 当前发生的信号
	struct sigaction sigaction[32]; // 信号的处理方式
    long blocked; /* 信号的屏蔽位图 */
    ...
};
```

有过有信号需要发给进程，则将进程的任务控制块的`signal`变量中信号索引所对应位置位，比如进程定时到期时，就直接将`SIGALARM`对应的位置为1，代码如下所示：

``` // kernel/sched.c
void schedule(void){
    ......
    if ((*p)->alarm && (*p)->alarm < jiffies) {
        (*p)->signal |= (1<<(SIGALRM-1));
        (*p)->alarm = 0;
    }
    ......
}
```

而信号的处理只有在两个时机，一个是系统调用返回时会检测是否当前进程有信号要处理，再一个是时钟中断处理后返回R3层时，也会检测。在其他的中断中就不会检测信号了，这也是防止出现问题。两块代码摘要如下：

```
system_call:
	...
	cmpl $0,counter(%eax)		# counter
	je reschedule
ret_from_sys_call:
	movl current,%eax
	cmpl task,%eax			# task[0] cannot have signals
	je 3f
	cmpw $0x0f,CS(%esp)		# was old code segment supervisor ?
	jne 3f
	cmpw $0x17,OLDSS(%esp)		# was stack segment = 0x17 ?
	jne 3f
	movl signal(%eax),%ebx
	movl blocked(%eax),%ecx
	notl %ecx
	andl %ebx,%ecx
	bsfl %ecx,%ecx
	je 3f
	btrl %ecx,%ebx
	movl %ebx,signal(%eax)
	incl %ecx
	pushl %ecx
	call do_signal
	popl %ecx

timer_interrupt:
	...
	pushl %eax
	call do_timer		# 'do_timer(long CPL)' does everything from
	addl $4,%esp		# task switching to accounting ...
	jmp ret_from_sys_call
```

从这里可知只有在非任务0中，且系统调用来自于R3时才会检测信号，将signal中的信号用blocked做过滤后，查看是否有要处理信号，如果有则调用`do_signal`函数。在`do_signal`中根据任务控制块中的`sigaction`成员来确定指定信号的处理方式。如果信号设置了重启系统调用，那么则在调用信号处理函数之前要重置一下`eax`和`eip`等寄存器的值，以便重启系统调用；如果信号的处理非忽略和系统默认，则是R3调用`signal`或`sigaction`函数进行了修改，那么就要安排调用R3的处理函数。

调用R3的处理函数是通过修改当前系统调用栈上的EIP来达到会到R3即调用`sa_handler`的目的，而在调用完函数后还需要无痕迹地清理栈，并且跳转回发起系统调用代码处继续执行后面的代码。这需要在修改EIP的同时将原返回地址压入R3栈，同时还包括EAX等寄存器，而这些寄存器的恢复和跳回原返回地址是由`sigaction`成员中的`sa_restorer`指针所指向代码段来完成，这个指针其实是LibC库中提供的函数，`____sig_restore`或`____masksig_restore`。

如上为信号的简单总结，详细内容可以参考`signal.h`和`signal.c`两个文件中详细实现。


By Andy @2019-06-16 14:55:21

