
#Linux-0.12源码阅读总结#

虽然`Linux-0.12`的源码量不大，但是要逐一弄清楚也不是一天两天的事，参考赵炯先生的《Linux内核完全剖析》将代码阅读了一遍，但是往往专注于函数或细节时就容易忽略大的框架，也容易将相关的整体机制或功能割裂，这里将阅读过程中的一些自认为比较完整的一些过程或机制总结一下，作为今后查阅的资料备份。

### 引导过程 ###

机器一旦加电，BIOS即进行硬件自检，完成后将引导设备上的引导扇区加载到`0x7c00`地址处，跳转到这个地址上开始执行引导扇区的代码。

**boot/bootsect.S**

`linux0.12`中引导扇区对应文件`bootsect.S`，它首先将自己移动到`0x90000`地址处（现在占用的这地地址处后面要加载内核），校正磁盘的参数，确保最大扇区数设置为18。加载引导扇区后的四个扇区到引导扇区后面的地址处，这四个扇区中保存了`setup.S`文件编译出的代码，后面会简单说这个模块。输出引导信息，然后调用`read_it`函数将真正的内核文件加载起来，它位于`setup.S`编译出来的模块之后，它的加载地址为`0x10000`。

其实这里的引导程序限制了`setup.S`的大小，最大不能超过四个扇区，即2Kb；而真正的内核文件的大小也有限制，从现在看它是从`0x10000`地址开始加载，而结束地址则为`0x90000`，如果超过这个地址就覆盖到了正执行的这个引导扇区，所以内核文件最大为`0x80000`，在当时Linus先生认为这个大小足够了。

> 这有一个问题，为什么内核模块要从`0x10000`开始进行加载呢？如果从`0x0`岂不是更方便？如果对BIOS有所了解就会知道，BIOS中断位于0地址开始处，占用1Kb空间。如果从0地址开始加载，那么这些中断函数就会被覆盖，后面`setup.S`中还需要使用BIOS中断获取信息，所以这里要闪开0地指处1K。

**boot/setup.S**

setup模块首先使用BIOS中断获取了硬盘，显示器，内存等参数，这些参数在后面初始化Linux系统有用处；获取硬盘参数列表，并且判断系统的硬盘`hd1`是否存在。这些数据被放在`0x90000`地址开始的内存中，这段内存用于放置引导扇区，前面已经执行完毕，这里重用这块内存。对于显示参数，如果获取的不对，则调用chsvga函数根据显卡类型获取参数。

完成参数获取后，BIOS中断的使命也就完成了，这里就将整个内核模块system向前移动到了0地址处，system模块编译时指定起始地址为0，所以这里将它移动到0地址处也不需要进行重定位了。

接下来就是完成系统保护开启设置了：

* 加载IDTR寄存器
* 加载GDTR寄存器
* 开启A20地址线（使用键盘接口）
* 重置8259A芯片，设置中断号从`0x20`开始，并且屏蔽掉所有中断
* 开启保护模式，并进行长跳转完成CS寄存器切换

开启保护模式后长跳转指令为`ljmp 0, 8`，即设置cs寄存器为`0x8`，eip为0。根据GDT表可知这个地址`0x0008:0x00000000`其实就是当前的物理0地址，即system模块的起始处（前面进行的复制）。

**boot/head.s**

setup 模块的开始处其实是`head.s`文件编译出的模块，setup中进行保护模式设置，并进入了保护模式。这里则继续进行系统的初始化设置。

首先重置各个数据段寄存器，然后重新加载`IDTR/GDTR`两个寄存器，前面setup中设置的中断表和全局描述符表位于setup中，这块内存在后面会被用作其他地方，防止被覆盖则需要将这两个表设置到不会被覆盖的地方，这里及head中的末尾处，它是内核模块，占用内存在整个操作系统生命周期中也不会挪作它用。

注意这里设置了栈，它是从`stack_start`结构体中加载的内容，这是这里将栈底设置为`user_stack`，它就是之后第一个进程所用的用户栈（现在还没有开启分页，还没有区分R3和R0，所以这个内存内核先用着，后面就专用于R3栈了，内核栈会重新设置）。检查A20地址线是否开启，检查浮点数运算芯片。

下面就是设置页表，将从0地址开始的五页设置为初始页表，第一页用作页目录，后面四页作为映射16M物理内存的页表项进行初始化，即`0-16M`的物理内存与地址空间的`0-16M`作一对一映射，这里一方面方便内核初始化，也方便物理内存管理。设置完页表后，即可开启分页，然后跳转到内核C代码的入口地址处。

这里的C代码入口函数即`init/main.c`中的`main`函数。

**init/main.c**

`main.c`中代码比较简单，但是它涉及的知识很多，这里简要叙述一下它的过程，详细内容再阅读具体代码。

首先设置环境变量，将硬盘参数复制到全局变量中保存，以备后面使用；根据内存大小，设置块设备缓冲区，虚拟盘所占内存，最后将剩余内存都充做主内存，用于分配。后面依次对系统的各个部分进行初始化，如下：


* 内存初始化： 内存初始化中，将主内存按照4K分块，`mem_map`数组每项指向主内存的4K块，用于表示当前块有没有被引用，以及被引用几次。对于不满16M时，将后面不满16M的map项设置为已占用，防止出错。
* 中断初始化：调用`set_trap_gate`和`set_system_gate`来设置IDT表中的对应中断项，主要是设置其响应函数。将不支持的中断项设置为`reserved`，防止出现后造成系统崩溃。最后开启两片中断芯片的链接。
* 块设备初始化：块设备请求时，将所有信息封装成一个request项，这里只需要将request数组各项初始化即可。
* 字符设备初始化：实际为空，字符设备无需在此初始化。
* tty设备以及串口和控制台初始化：这个主要是这三项中用到的串口表，伪终端表，控制台表，串口请求项等初始化。
* 时间初始化：将从CMOS中读取的时间转换为开机时间，作为之后计算其他时间基础。
* 调度初始化：即手工设置第一个进程，设置tss，ldt在GDT中表项，加载TR寄存器和LDTR寄存器，设置定时芯片的中断响应函数，以及系统调用。这基本为第一个进程的执行准备好了条件。
* 块设备缓存初始化：这个主要完成了块缓存区的初始化，从低内存开始保存块设备请求项缓存块描述符，高地址处以1K大小划分内存，直到将整个块设备缓存区消耗完。
* 硬盘初始化：设置硬盘中断响应函数，并且开启硬盘中断。
* 软盘初始化：设置软盘的中断响应函数，开启软盘中断屏蔽位。

最后开启终端，调用`move_to_user_mode()`宏通过在栈上构建终端返回栈帧，经过`iret`指令返回到R3继续执行。这里返回R3就是执行在了任务0中，任务0是空闲进程，系统进入空闲状态后会切换到该进程。

同时任务0在进入空闲状态之前，首先会调用 `fork`函数创建init进程，它用于进一步初始化。在init进程中，它完全复制了任务0的进程信息，开始初始化系统的硬盘信息，加载根文件系统。打开标准输入输出句柄，创建shell进程执行初始化文件`/etc/rc`，而init在初始化文件完成后，创建shell接口进程，进而退化为Shell进程的Deamon进程，用于监控Shell进程退出后再次执行该进程。

至此，整个引导过程结束，系统进入到Shell接口，可以开始接收用户输入，执行Shell命令。

### 内存管理 ###

内存管理分为物理内存管理和虚拟内存管理，在虚拟内存管理中其实还包含了块设备缓冲区，虚拟盘，应用层的堆内存管理等。

内核管理所有物理内存，可以访问整个物理空间

单个进城使用该任务号对应的64M内存空间（虚拟地址），跳入内核则切换段寄存器，代码和数据，由于所有进城使用一个页表，进城切换不需要切换页表

缺页处理—
execve并没有对内存分页进行处理，仅处理了参数与环境变量，分配具体物理页！其他部分则设定执行文件inode，代码起始地址，数据起始地址。
在缺页处理中，根据当前缺页的地址，计算出它属于什么，首先确定是否是需换入页，其次看它是代码，数据，还是用于堆与栈的内存（空白），代码与数据即用前面execve中设置的代码和数据范围来判断！


13
-------------------------------------
关于物理内存管理，按照Linux 0.12中用户划分后，分为内核区，块设备缓冲区，虚拟磁盘，主内存四部分
物理内存最大支持16M，而内核使用的虚拟地址范围也为0-16M，且将物理内存16M一一映射到内核虚拟地址范围。
所以在内核中使用内核的GDT的代码与数据表项都能访问0-16M的物理内存。

>> 后面阅读高版本源码时，每个进程4G虚拟内存，内核占据高端1G虚拟内存时，物理内存的管理方法。


--------------------------------------
交换分区：
交换分区是块设备中独立的一个分区，初始化交换分区即将该分区的第一个"页"大小的磁盘块读入内存，校验交换分区标记

交换分区最多支持 SWAP_BITS 大小的交换分区，一旦大于这个值则将交换分区设置为该值。

由于交换分区位图中最后10个字节为标记，且校验后清0，所以如果交换分区足够大，那么10个字节中的位对应的
交换块就废弃了。

由于位图块是不会被写入到磁盘的，所以它保持了格式化磁盘后的状态。


### 系统调用 ###



### 读取硬盘过程 ###



### 打开一个文件的过程 ###



### execve执行过程 ###




### 字符设备 ###


（输出一个字符/读入一个字符）

    包括tty，chr_dev  相互之间关系


### 信号机制 ###



### 文件系统对设备的抽象 ###



By Andy @2019-06-16 14:55:21

