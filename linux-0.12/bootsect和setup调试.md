
启动初始化

bootsect.S和setup.S两个文件编译的引导部分代码可以使用gdb进行调试，但是比较费劲。它们本身是汇编，并且会需要查看GDT/LDT等寄存器，使用bochs的内置调试器比较方便。bochs可以编译多个版本，可以在bochs中编译内置的gdbstub，用于gdb链接调试；另外一种是编译内置调试器的bochs版本。这里调试要用内置调试器的Bochs版本。

使用如下命令可以启动bochs，其中`-q`表示静默启动，不显示菜单；`-f bochsrc.bxrc`用于指定配置文件。

```
bochs -q -f bochsrc.bxrc
```

Bochs启动后，它会停在如下的地址处：

```
[0x0000fffffff0] f000:fff0 (unk. ctxt): jmpf 0xf000:e05b
```

这就是PC加电后执行的第一条指令，跳转到`0xf000:e05b`处执行，这个地址是BIOS映射的物理地址。在BIOS中主要完成硬件的自检，校验等工作。BIOS在自检完毕后，会将引导盘的地一个扇区加载进内存，这里即bootsect.S编译的代码加载到0x7C00地址处，这个地址也是一个物理地址。执行命令`b 0x7c00`在起始点设置断点，`c`命令继续执行。

###bootsect模块###

`bootsect.S`中做的第一件事即是将`bootsect`块移动到`0x90000`起始的地址处，然后跳转过去，即`[0x000000007c13] 0000:7c13 (unk. ctxt): jmpf 0x9000:0018`。接下来，代码对寄存器进行初始化，并且初始化堆栈。从代码看`ss`寄存器设置为`0x9000`，而`sp`设置为`0xfef4`,即栈顶为`0x9000:0xfef4`，后面会看到这个地址往高地址方向存放了软驱参数。

这块其实有个错误，`push ax`指令放到了栈初始化之前，那么后面对应的对`ax`的出栈就发生了错误了，所以这里修改一下，将该指令放到栈初始化之后。

Linus当时的BIOS默认不支持多扇区加载，需要自己进行修改，所以他接下来将BIOS默认的最大扇区数修改为18。其实对于现在的BIOS，这个值本身就是18。磁盘参数表的地址位于地址`0x0000:0x0078`处，磁盘参数表为12字节，格式如下：

**硬盘基本参数表**

中断向量表中，int 0x41 的中断向量位置（4 * 0x41 =0x0000:0x0104）存放的并不是中断程序的地址而是第一个硬盘的基本参数表。对于100%兼容的BIOS 来说，这里存放着硬盘参数表阵列的首地址F000h:E401h。第二个硬盘的基本参数表入口地址存于int 0x46 中断向量中。

|偏移量(字节) |	描述 |
|------------|-------|
|0-1 |	软盘控制器（端口3F5h) |
|2  | 驱动器休眠马达关闭延时 |
|3  | 每扇区字节数：0=128 bytes；1=256 bytes；2=512 bytes；3=1024 bytes；4=2048 bytes；5=4096 bytes；7=16384 bytes；8-FFh=Reserverd|
|4  | 每磁道的扇区数： 09h=9 sectors，360K和720K；0Fh=15 sectors，1.2M；12h=18 sectors，1.44M；24h=36 sectors，2.88M|
|5  | 扇区之间的间隙长度：1Bh for 1.2M,1.44M and 2.88M floppy;2Ah for 360K and 720K floppy|
|6  | 数据长度 |
|7  | 格式化间隙长度 |
|8  | 格式化填充字节 |
|9  | 磁头定位时间 |
|A  | 等待马达开启时间 |

从调试可以看到，程序从`0x0000:0x0078`处加载的地址上传输了如下的内容。在地址`0xf000:0xefde`处其实就是上面的软盘参数表。例如第四个字节为`0x02`，其实它表示当前软盘的每扇区为512字节；其中第六个字节即下面要修改的内容。不过从这里看，它已经是`0x12`了，即18。

```
<bochs:27> x /6xh 0x0078
[bochs]:
0x00000078 <bogus+       0>:	0xefde	0xf000	0x1380	0xc000	0xff53	0xf000
<bochs:28> x /6xh 0xfefde
[bochs]:
0x000fefde <bogus+       0>:	0x02af	0x0225	0x1b12	0x6cff	0x0ff6	0x4f08
```

将上述的数据复制到了`0x9000:0xfef4`处，并修改了前面说的第六个字节；随后将BIOS的软盘参数表地址修改了，即`0x0000:0x0078`处地址修改为指向复制到的地址。

之后调用`int 0x13(19)`进行软驱的复位，其中寄存器`AH`保存功能号，`DL`保存驱动器号，`DL=0`表示第一个软驱，`DL=1`表示第二个软驱，`DL=80`表示第一个磁盘。

之后调用`int 0x13`进行软盘读取，`AH=2`表示读取软盘扇区，`AL=0x04`表示要读取4个扇区，`ES:BX`表示要读入的内存地址，`CX`寄存器的低6位表示要读取的磁道上的扇区号（从0~17），高10位则表示要读取的磁道号（从0开始），`DH`为磁头号，`DL`依旧为驱动器号，即读取软盘还是磁盘。根据代码要读入的内存地址为`0x9000:0x0200`，查看内容如下。

```
<bochs:49> x /10xb 0x90200
[bochs]:
0x00090200 <bogus+       0>:	0xb8	0x00	0x90	0x8e	0xd8	0xb4	0x88	0xcd
0x00090208 <bogus+       8>:	0x15	0xa3
```

读取完`setup.S`编译的模块后，又一次调用`int 0x13`的`0x08`号功能，用于获取当前驱动器参数。该中断调用具体的返回值可以参照资料，这里取了`CL`寄存器低6位的每磁道的扇区数。将它放进了`sectors`变量中，用于下面读取更多扇区时用。

下面先调用了`int 0x10`的3号功能，用于读取当前的光标位置；根据读取的光标位置（DX中），接下来则调用`int 0x10`的`0x13`号功能显示字符串，即显示`Loading`几个字符。

重置`es`寄存器的值，然后读取磁盘上`system`模块的内容到内存，起始地址为`0x10000`。在读取磁盘时也采用BIOS中断的方式，一次读取一个磁道的全部内容，并且每次读完一个磁道，则打印一个`.`字符，表示在继续加载内容。


加载完`system`模块后，关闭软驱驱动器，打印换行字符。

如果没有制定引导设备，则根据前面读取的当前磁盘驱动器的扇区数，确定使用的引导设备是什么！`1.2M`的软盘还是`1.44M`的软盘，将结果写回到引导山区的509,510两个字节

最后跳转到`0x9020:0x0000`地址处继续执行，这里就跳转到了`setup.S`编译的代码块中了。

###setup模块###


By Andy @



