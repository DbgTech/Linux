
# 试验总结 #

听了一下哈工大的操作系统课程，里面有几个试验，可以帮助加深对Linux0.12的理解，这里将实验过程中的一些内容做个总结。github上关于试验的要求[哈工大操作系统实验手册](https://hoverwinter.gitbooks.io/hit-oslab-manual/content/index.html)，实验楼也有相关的实验，[操作系统原理与实践](https://www.shiyanlou.com/courses/115)，两部分内容几乎相同，参考其中一个即可。

### 一. 操作系统的引导 ###

实验一中主要检查对系统引导的理解，这一部分其实就将原有代码进行修修补补即可。在`bootsect.S`中字符串输出的代码，直接照抄即可。对于内存中的十六进制输出，在这个`bootsect.S`中也有代码，`print_nl`输出换行，`print_hex`则输出`ss:bp`指向内存处的一个字，以十六进制形式输出。

这里面有一个比较容易出问题的地方，就是在调用`bootsect.S`中的输出函数时，会影响到`edx`等寄存器的值，而在再次调用比如`print_hex`时会出现打印的位置混乱。所以在每次调用完了，重新读一下光标位置，在继续输出。

仿照`print_hex`改了两个函数，`print_str`和`print_byte`，方便输出内容。

详细代码可以参考`linux-0.12\labs\lab1`目录下的源码。

### 二. 系统调用 ###

试验二为添加系统调用`iam`和`whoami`，添加系统调用容易将应用层的SDK和内核中的实际函数混淆，实现的内核中的内容并不需要`int 0x80`的汇编代码，这部分内容其实是需要在SDK中编写的，比如如下为`close()`系统调用的实现，其代码中为宏定义`_syscall1(int,close,int,fd)`，展开宏后代码形式如下所示：

```
int close(int fd)
{
    long __res;
    __asm__ volatile ("int $0x80"
        : "=a" (__res)
        : "0" (__NR_close),"b" ((long)(fd)));
    if (__res >= 0)
        return (int) __res;
    errno = -__res;
    return -1;
}
```

可知系统调用使用`int 0x80`，其中`eax`中保存了一个值`__NR_close`，`ebx`等寄存器传参。`__NR_close`其实也是一个宏定义，它位于`include/unistd.h`中，它其实是系统调用号，用于下面即将要说的系统调用表的查表索引。首先就需要添加新的系统调用号，用于标识新的系统调用，代码如下。

```
......
#define __NR_uselib	86

#define __NR_iam 87         // 新加入的系统调用号
#define __NR_whoami 88

#define _syscall0(type,name) \
......
```

执行了中断指令后就会进入内核，如下为`int 0x80`中断的处理函数`system_call`的部分汇编：

```
......
system_call:
	push %ds
	push %es
	push %fs
	pushl %eax		# save the orig_eax eax寄存器保存系统调用号
	pushl %edx
	pushl %ecx		# push %ebx,%ecx,%edx as parameters，ebx/ecx/edx是系统调用参数
	pushl %ebx		# to the system call
	movl $0x10,%edx		# set up ds,es to kernel space
	mov %dx,%ds
	mov %dx,%es
	movl $0x17,%edx		# fs 寄存器指向用户空间
	mov %dx,%fs
	cmpl NR_syscalls,%eax # 对比系统调用号是否比系统调用数多
	jae bad_sys_call
	call sys_call_table(,%eax,4) # 查找 sys_call_table 表，查找要调用的系统调用
	pushl %eax
......
```

从汇编代码可以很容易了解到，系统调用是`int 0x80`中断中，根据`eax`寄存器传入的系统调用号查找系统调用表`sys_call_table`中对应的系统调用处理函数，然后跳转过去进行处理。所以要添加系统调用，首先要在`sys_call_table`中添加两项内容（该全局变量位于`include\linux\sys.h`中）。如下代码所示，添加两个函数声明，然后在表的结尾处添加两项。

```
......
extern int sys_uselib();

extern int sys_iam();
extern int sys_whoami();

fn_ptr sys_call_table[] = { sys_setup, sys_exit, sys_fork, sys_read,
sys_write, sys_open, sys_close, sys_waitpid, sys_creat, sys_link,
sys_unlink, sys_execve, sys_chdir, sys_time, sys_mknod, sys_chmod,
sys_chown, sys_break, sys_stat, sys_lseek, sys_getpid, sys_mount,
sys_umount, sys_setuid, sys_getuid, sys_stime, sys_ptrace, sys_alarm,
sys_fstat, sys_pause, sys_utime, sys_stty, sys_gtty, sys_access,
sys_nice, sys_ftime, sys_sync, sys_kill, sys_rename, sys_mkdir,
sys_rmdir, sys_dup, sys_pipe, sys_times, sys_prof, sys_brk, sys_setgid,
sys_getgid, sys_signal, sys_geteuid, sys_getegid, sys_acct, sys_phys,
sys_lock, sys_ioctl, sys_fcntl, sys_mpx, sys_setpgid, sys_ulimit,
sys_uname, sys_umask, sys_chroot, sys_ustat, sys_dup2, sys_getppid,
sys_getpgrp, sys_setsid, sys_sigaction, sys_sgetmask, sys_ssetmask,
sys_setreuid,sys_setregid, sys_sigsuspend, sys_sigpending, sys_sethostname,
sys_setrlimit, sys_getrlimit, sys_getrusage, sys_gettimeofday, 
sys_settimeofday, sys_getgroups, sys_setgroups, sys_select, sys_symlink,
sys_lstat, sys_readlink, sys_uselib, sys_iam, sys_whoami};
......
```

单独编写一个`who.c`用于保存两个系统调用的实现，`sys_iam()`和`sys_whoami()`，这个代码详细参考`linux-0.12\labs\lab2\kernel\who.c`中的代码。

最后就是要修改Makefile，让新加入的`who.c`编译到内核中去，这个写法可以参考`kernel/Makefile`中其他项的写法，比如`exit.c`文件。

到此，如果编译通过，那么新的系统调用的添加就算完成了。

** 测试 **

要对新的系统调用进行测试，就需要编写代码，调用新加的系统调用。因为现在我们只是在内核中添加了系统调用，按照道理需要修改linux文件系统中的`usr/include`和`usr/lib`等中的文件，提供新的库内容。

这里为了省事，直接在`usr/include/unistd.h`中添加新的系统调用号，然后在测试代码`iam.c`和`whoami.c`中使用宏定义添加`iam()`和`whoami()`两个库函数，这样就可以在其中写代码直接调用函数进行测试了。

`unistd.h`，`whoami.c`和`iam.c`三个文件可以参考`linux-0.12\labs\lab2-test`中的三个文件。

### 三. 进程运行轨迹跟踪与统计 ###

进程的运行轨迹可以根据进程在不同时刻的状态来体现，在Linux 0.12中进程有如下的几种状态：

```
进程新建   - N   // 进程创建中，还无法调度
进入就绪态 - J   // 进程可以被调度
进入运行态 - R   // 进程分配到CPU，可以执行代码
进入阻塞态 - W   // 进程进入阻塞状态，主要是调用sleep，pause等
退出      - E   // 进程最后退出
```

所以要跟踪进程的轨迹，那就要将进程几个状态变化记录下来，这样就可能看出一个进程从诞生到消亡这段时间它都在做什么了。

首先要添加一个log文件，这里采用特殊手段，我们知道任务1在执行了作为用户接口的shell程序之后，就一直处于监控该进程的状态，它是一直不退出的。其次要写日志，那就要打开文件，从系统初始化过程可知，在任务1中，首先调用setup函数进行了文件系统的挂载，所以只能在这个函数调用后才能打开文件。

所以这里我们将日志文件打开在任务1中，并且使用3号或更高的文件句柄，代码如下：

```
void init(void)
{
	......
    (void) dup(0);
    (void) open("/var/process.log", O_CREAT | O_TRUNC | O_WRONLY, 0666);
    printf("%d buffers = %d bytes buffer space\n\r",NR_BUFFERS,
        NR_BUFFERS*BLOCK_SIZE);
	......
```

那么写文件则需要额外处理下，在应用程序中可以直接调用`fprintf`来向一个文件中格式化字符串，这里就不能直接使用这个函数了，如同应用层的`printf`无法调用一样，这里额外添加一个函数`fprintk`专门用于内核中写文件。

```
#include "linux/sched.h"
#include "sys/stat.h"

static char logbuf[1024];
int fprintk(int fd, const char *fmt, ...)
{
    va_list args;
    int count;
    struct file * file;
    struct m_inode * inode;

    va_start(args, fmt);
    count=vsprintf(logbuf, fmt, args);
    va_end(args);

    if (fd < 3)
    {
        __asm__("push %%fs\n\t"
            "push %%ds\n\t"
            "pop %%fs\n\t"
            "pushl %0\n\t"
            "pushl $logbuf\n\t"
            "pushl %1\n\t"
            "call sys_write\n\t"
            "addl $8,%%esp\n\t"
            "popl %0\n\t"
            "pop %%fs"
            ::"r" (count),"r" (fd):"ax","cx","dx");
    }
    else
    {
        if (!(file=task[0]->filp[fd]))
            return 0;
        inode=file->f_inode;

        __asm__("push %%fs\n\t"
            "push %%ds\n\t"
            "pop %%fs\n\t"
            "pushl %0\n\t"
            "pushl $logbuf\n\t"
            "pushl %1\n\t"
            "pushl %2\n\t"
            "call file_write\n\t"
            "addl $12,%%esp\n\t"
            "popl %0\n\t"
            "pop %%fs"
            ::"r" (count),"r" (file),"r" (inode):"ax","cx","dx");
    }
    return count;
}
```

这里对与`0-2`的文件句柄都默认调用`sys_write`，但是对于大于等于3的句柄则调用`file_write`，做这个特殊处理的原因是，在`sys_write`中会使用当前进程的句柄表，但是我们这里要写入的文件打开于进程1的句柄表中，所以这里不能调用这个函数，下面找到进程1中的文件表项后，直接调用了`file_write`函数。

在对状态转移的时间记录上直接采用了`jiffies`，这个变量中保存了从开机到现在为止的`滴答数`，其实就是以`100ms`为间隔的时钟中断数。

要寻找进程状态的切换点，就要对代码中 `fork.c`和`sched.c`有比较详细了解：

首先进程新建，其对应的系统调用为`sys_fork`，可到其代码可以发现真正完成工作的是函数`copy_process`，所以在该函数为进程分配了pid后，马上输出一条信息，即进程创建。

在完成了整个进程创建后，即复制了内存页表，复制了打开文件表等，进程就可以进行调度了，此时进程进入就绪状态，即`copy_process`函数的最后。

进程要想进入运行态，那必须要被调度拥有CPU才可以，所在在`schedule()`函数最后调用完`switch_to`后添加进程进入运行状态的信息输出。

进入阻塞态的情况就比较多了，调用`sys_pause`，`sleep_on`，`interruptible_sleep_on`，如果当前进程处于等待队列中，但是不是队列的第一个成员，那么唤醒后它马上又会进入到等待状态。

进程被唤醒进入就绪状态也有几处，`wake_up`函数负责将不可中断等待进程唤醒，而在调度过程中会判断进程是否有定时器超时，或有信号，如果有且进程处于可中断等待状态，那么将进程转为就绪。不可中断等待中，也可能使得进程进入到就绪状态。

退出状态在`do_exit`函数中，即将进程状态设置为僵尸状态时，输出退出状态信息。

> 涉及状态的文件包括`fork.c`，`sched.c`，`exit.c`三个文件。


### 四. 基于内核栈切换的进程切换 ###


### 五. 信号量的实现和应用 ###

### 六. 地址映射与共享 ###


### 七. 终端设备的控制 ###



### 八. proc文件系统的实现 ###




By Andy @2019-05-26 15:45:23