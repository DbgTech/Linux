
# 试验总结 #

听了一下哈工大的操作系统课程，里面有几个试验，可以帮助加深对Linux0.12的理解，这里将实验过程中的一些内容做个总结。github上关于试验的要求[哈工大操作系统实验手册](https://hoverwinter.gitbooks.io/hit-oslab-manual/content/index.html)，实验楼也有相关的实验，[操作系统原理与实践](https://www.shiyanlou.com/courses/115)，两部分内容几乎相同，参考其中一个即可。

### 一. 操作系统的引导 ###

实验一中主要检查对系统引导的理解，这一部分其实就将原有代码进行修修补补即可。在`bootsect.S`中字符串输出的代码，直接照抄即可。对于内存中的十六进制输出，在这个`bootsect.S`中也有代码，`print_nl`输出换行，`print_hex`则输出`ss:bp`指向内存出的一个字，以十六进制形式输出。

这里面有一个比较容易出问题的地方，就是在调用`bootsect.S`中的输出函数时，会影响到`edx`等寄存器的值，而在再次调用比如`print_hex`时会出现打印的位置混乱。所以在每次调用完了，重新读一下光标位置，在继续输出。

仿照`print_hex`改了两个函数，`print_str`和`print_byte`，方便输出内容。

详细代码可以参考`linux-0.12\labs\lab1`目录下的源码。


### 二. 系统调用 ###

试验二为添加系统调用`iam`和`whoami`，添加系统调用容易将应用层的SDK和内核中的实际函数混淆，实现的内核中的内容并不需要`int 0x80`的汇编代码，这部分内容其实是需要在SDK中编写的，比如如下为`close()`系统调用的实现，其代码中为宏定义`_syscall1(int,close,int,fd)`，展开宏后代码形式如下所示：

```
int close(int fd)
{
    long __res;
    __asm__ volatile ("int $0x80"
        : "=a" (__res)
        : "0" (__NR_close),"b" ((long)(fd)));
    if (__res >= 0)
        return (int) __res;
    errno = -__res;
    return -1;
}
```

可知系统调用使用`int 0x80`，其中`eax`中保存了一个值`__NR_close`，`ebx`等寄存器传参。`__NR_close`其实也是一个宏定义，它位于`include/unistd.h`中，它其实是系统调用号，用于下面即将要说的系统调用表的查表索引。首先就需要添加新的系统调用号，用于标识新的系统调用，代码如下。

```
......
#define __NR_uselib	86

#define __NR_iam 87         // 新加入的系统调用号
#define __NR_whoami 88

#define _syscall0(type,name) \
......
```

执行了中断指令后就会进入内核，如下为`int 0x80`中断的处理函数`system_call`的部分汇编：

```
......
system_call:
	push %ds
	push %es
	push %fs
	pushl %eax		# save the orig_eax eax寄存器保存系统调用号
	pushl %edx
	pushl %ecx		# push %ebx,%ecx,%edx as parameters，ebx/ecx/edx是系统调用参数
	pushl %ebx		# to the system call
	movl $0x10,%edx		# set up ds,es to kernel space
	mov %dx,%ds
	mov %dx,%es
	movl $0x17,%edx		# fs 寄存器指向用户空间
	mov %dx,%fs
	cmpl NR_syscalls,%eax # 对比系统调用号是否比系统调用数多
	jae bad_sys_call
	call sys_call_table(,%eax,4) # 查找 sys_call_table 表，查找要调用的系统调用
	pushl %eax
......
```

从汇编代码可以很容易了解到，系统调用是`int 0x80`中断中，根据`eax`寄存器传入的系统调用号查找系统调用表`sys_call_table`中对应的系统调用处理函数，然后跳转过去进行处理。所以要添加系统调用，首先要在`sys_call_table`中添加两项内容（该全局变量位于`include\linux\sys.h`中）。如下代码所示，添加两个函数声明，然后在表的结尾处添加两项。

```
......
extern int sys_uselib();

extern int sys_iam();
extern int sys_whoami();

fn_ptr sys_call_table[] = { sys_setup, sys_exit, sys_fork, sys_read,
sys_write, sys_open, sys_close, sys_waitpid, sys_creat, sys_link,
sys_unlink, sys_execve, sys_chdir, sys_time, sys_mknod, sys_chmod,
sys_chown, sys_break, sys_stat, sys_lseek, sys_getpid, sys_mount,
sys_umount, sys_setuid, sys_getuid, sys_stime, sys_ptrace, sys_alarm,
sys_fstat, sys_pause, sys_utime, sys_stty, sys_gtty, sys_access,
sys_nice, sys_ftime, sys_sync, sys_kill, sys_rename, sys_mkdir,
sys_rmdir, sys_dup, sys_pipe, sys_times, sys_prof, sys_brk, sys_setgid,
sys_getgid, sys_signal, sys_geteuid, sys_getegid, sys_acct, sys_phys,
sys_lock, sys_ioctl, sys_fcntl, sys_mpx, sys_setpgid, sys_ulimit,
sys_uname, sys_umask, sys_chroot, sys_ustat, sys_dup2, sys_getppid,
sys_getpgrp, sys_setsid, sys_sigaction, sys_sgetmask, sys_ssetmask,
sys_setreuid,sys_setregid, sys_sigsuspend, sys_sigpending, sys_sethostname,
sys_setrlimit, sys_getrlimit, sys_getrusage, sys_gettimeofday, 
sys_settimeofday, sys_getgroups, sys_setgroups, sys_select, sys_symlink,
sys_lstat, sys_readlink, sys_uselib, sys_iam, sys_whoami};
......
```

单独编写一个`who.c`用于保存两个系统调用的实现，`sys_iam()`和`sys_whoami()`，这个代码详细参考`linux-0.12\labs\lab2\kernel\who.c`中的代码。

最后就是要修改Makefile，让新加入的`who.c`编译到内核中去，这个写法可以参考`kernel/Makefile`中其他项的写法，比如`exit.c`文件。

到此，如果编译通过，那么新的系统调用的添加就算完成了。

** 测试 **

要对新的系统调用进行测试，就需要编写代码，调用新加的系统调用。因为现在我们只是在内核中添加了系统调用，按照道理需要修改linux文件系统中的`usr/include`和`usr/lib`等中的文件，提供新的库内容。

这里为了省事，直接在`usr/include/unistd.h`中添加新的系统调用号，然后在测试代码`iam.c`和`whoami.c`中使用宏定义添加`iam()`和`whoami()`两个库函数，这样就可以在其中写代码直接调用函数进行测试了。

### 三. 进程运行轨迹跟踪与统计 ###



### 四. 基于内核栈切换的进程切换 ###


### 五. 信号量的实现和应用 ###

### 六. 地址映射与共享 ###


### 七. 终端设备的控制 ###



### 八. proc文件系统的实现 ###




By Andy @2019-05-26 15:45:23